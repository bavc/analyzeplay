#!/bin/bash
[ ! $(which ffplay) ] && { echo ffplay is necessary to run this. Maybe you can install it with: 'brew install --with-ffplay --with-freetext ffmpeg'; exit 1 ;};

usage(){
    echo "
    $(basename $0)

    usage: $(basename $0) [ filteroption ] [ -o outputfile ] inputfile

    use - (hyphen) for the input if it is a pipe (for instace: bmdcapture -v -F nut -c 2 -s 16 -p 8 -m 0 -f pipe:1 | analyzeplay -c -)

    filter options:
    -f        split field mode
    -d        field difference mode. midtone gray means no difference in between fields
    -H        field histogram mode, histograms per field
    -b        bit slice playback per field, enter 1 through 8 to show that bit value (only supports the most significant 8 bits)
    -A        field waveform mode with highlights for broadcast range (draft #2)
    -B        field waveform mode with highlights for broadcast range on field 1 only
    -C        field waveform mode with highlights for broadcast range on field 2 only
    -D        field waveform mode with highlights for broadcast range showing field 1 on top and field 2 on bottom
    -E        highlight pixels that are outside of broadcast range
    -F        highlight pixels that are outside of broadcast range showing field 1 on top and field 2 on bottom
    -J        vectorscope mode (draft #2)
    -K        vectorscope mode on field 1 only
    -L        vectorscope mode on field 2 only
    -M        vectorscope mode showing field 1 on left and field 2 on right
    -N        highlight pixels that are labelled as temporal outliers
    -O        highlight pixels that are labelled as temporal outliers showing field 1 on top and field 2 on bottom

    optional output:
    -o        outputfile

    "
}

# filter recipes
fieldsplitplay="-vf 'split[a][b]; [a]pad=iw:ih*2,field=top[src]; [b]field=bottom[filt]; [src][filt]overlay=0:h'"
fielddiffplay="-vf 'split[a][b];[a]field=bottom[bb];[b]field=top,negate[tb];[bb][tb]blend=all_mode=average'"

#depreciated chromasplitplay="-vf 'split=4[a][b][c][d];[a]pad=iw*2:ih*2[w];[b]lutyuv=u=128:v=128[x];[c]lutyuv=y=128:v=128,curves=strong_contrast[y];[d]lutyuv=y=128:u=128,curves=strong_contrast[z];[w][x]overlay=w:0[wx];[wx][y]overlay=0:h[wxy];[wxy][z]overlay=w:h'"
#depreciated interlaceplay="-vf 'kerndeint=map=1'"

# Name: Histogram
# Description: A histogram display for each channel of the input video (typically either in YUV or RBG).
FILTER_HISTOGRAM="-vf 'histogram'"
# Name: Histogram (Field Split)
# Description: A histogram display for each channel of the input video (typically either in YUV or RBG). Field 1 is presented on the left and field 2 on the right.
FILTER_HISTOGRAM_FS="-vf 'split[a][b];[a]field=top,histogram,pad=iw*2[a2];[b]field=bottom,histogram[b2];[a2][b2]overlay=w'"

# Name: Waveform
# Description: A waveform display. Guide lines are drawn at 7.5 IRE (0x16) and 100 IRE (0xEB). The area above 100 IRE is tinted in crimson and below 7.5 IRE is tinted aqua. These ranges, above 100 IRE and below 7.5 IRE, show luminosity values outside of broadcast range.
FILTER_WAVEFORM="-vf 'histogram=step=16:mode=waveform:waveform_mode=column:waveform_mirror=1,crop=iw:256:0:0,drawgrid=y=(256-16):c=white@0.4,drawgrid=y=(256-235):c=white@0.4,drawbox=y=(256-16):w=iw:h=16:color=aqua@0.2:t=16,drawbox=w=iw:h=(256-235):color=crimson@0.2:t=16,scale=720x486'"
# Name: Waveform (Field 1 Only)
FILTER_WAVEFORM_F1="-vf 'field=top,histogram=step=16:mode=waveform:waveform_mode=column:waveform_mirror=1,crop=iw:256:0:0,drawgrid=y=(256-16):c=white@0.4,drawgrid=y=(256-235):c=white@0.4,drawbox=y=(256-16):w=iw:h=16:color=aqua@0.2:t=16,drawbox=w=iw:h=(256-235):color=crimson@0.2:t=16,scale=720x486'"
# Name: Waveform (Field 2 Only)
FILTER_WAVEFORM_F2="-vf 'field=bottom,histogram=step=16:mode=waveform:waveform_mode=column:waveform_mirror=1,crop=iw:256:0:0,drawgrid=y=(256-16):c=white@0.4,drawgrid=y=(256-235):c=white@0.4,drawbox=y=(256-16):w=iw:h=16:color=aqua@0.2:t=16,drawbox=w=iw:h=(256-235):color=crimson@0.2:t=16,scale=720x486'"
# Name: Waveform (field-split)
FILTER_WAVEFORM_FS="-vf 'split[a][b];[a]field=top[c];[b]field=bottom[d];[c]histogram=step=16:mode=waveform:waveform_mode=column:waveform_mirror=1,crop=iw:256:0:0,drawgrid=y=(256-16):c=white@0.4,drawgrid=y=(256-235):c=white@0.4,drawbox=y=(256-16):w=iw:h=16:color=aqua@0.2:t=16,drawbox=w=iw:h=(256-235):color=crimson@0.2:t=16[e];[d]histogram=step=16:mode=waveform:waveform_mode=column:waveform_mirror=1,crop=iw:256:0:0,drawgrid=y=(256-16):c=white@0.4,drawgrid=y=(256-235):c=white@0.4,drawbox=y=(256-16):w=iw:h=16:color=aqua@0.2:t=16,drawbox=w=iw:h=(256-235):color=crimson@0.2:t=16[f];[e]pad=0:ih*2[g];[g][f]overlay=0:h'"

# Name: Broadcast Range Pixels
# Description: All pixels from 0 to 7.5 IRE and 100-110 IRE will be highlighted as white pixels to illuminate what area(s) of the frame and how many pixels are outside of braodcast range
FILTER_RANG="-vf 'values=out=rang'"
# Name: Broadcast Range (field-split)
FILTER_RANG_FS="-vf 'split[a][b];[a]field=top[c];[b]field=bottom[d];[c]values=out=rang[e];[d]values=out=rang[f];[e]pad=0:ih*2[g];[g][f]overlay=0:h'"

# Name: Vectorscope
# Description: A vectorscope display. This display plots chroma values (U/V color placement) in two dimensional graph (which is called a vectorscope). It can be used to read of the hue and saturation of the current frame. The whiter a pixel in the vectorscope, the more pixels of the input frame correspond to that pixel (that is the more pixels have this chroma value). The V component is displayed on the vertical (Y) axis, with the bottom edge being V = 0 and the top being V = 255. The U component is displayed on the horizontal (Y) axis, with the left representing U = 0 and the right representing U = 255.
FILTER_VECTORSCOPE="-vf 'histogram=mode=color2,transpose=dir=2,drawgrid=w=16:h=16:t=1:c=white@0.2,drawgrid=w=128:h=128:t=1:c=white@0.3,drawgrid=w=4:h=4:t=1:c=white@0.1,drawbox=w=5:h=5:t=1:x=90-2:y=256-240-3:c=red@0.5,drawbox=w=5:h=5:t=1:x=54-2:y=256-34-3:c=green@0.5,drawbox=w=5:h=5:t=1:x=240-2:y=256-110-3:c=blue@0.5,drawbox=w=5:h=5:t=1:x=166-2:y=256-16-3:c=cyan@0.5,drawbox=w=5:h=5:t=1:x=202-2:y=256-222-3:c=magenta@0.5,drawbox=w=5:h=5:t=1:x=16-2:y=256-146-3:c=yellow@0.5,scale=486:486'"
# Name: Vectorscope (Field 1 Only)
FILTER_VECTORSCOPE_F1="-vf 'field=top,histogram=mode=color2,transpose=dir=2,drawgrid=w=16:h=16:t=1:c=white@0.2,drawgrid=w=128:h=128:t=1:c=white@0.3,drawgrid=w=4:h=4:t=1:c=white@0.1,drawbox=w=5:h=5:t=1:x=90-2:y=256-240-3:c=red@0.5,drawbox=w=5:h=5:t=1:x=54-2:y=256-34-3:c=green@0.5,drawbox=w=5:h=5:t=1:x=240-2:y=256-110-3:c=blue@0.5,drawbox=w=5:h=5:t=1:x=166-2:y=256-16-3:c=cyan@0.5,drawbox=w=5:h=5:t=1:x=202-2:y=256-222-3:c=magenta@0.5,drawbox=w=5:h=5:t=1:x=16-2:y=256-146-3:c=yellow@0.5,scale=486:486'"
# Name: Vectorscope (Field 2 Only)
FILTER_VECTORSCOPE_F2="-vf 'field=bottom,histogram=mode=color2,transpose=dir=2,drawgrid=w=16:h=16:t=1:c=white@0.2,drawgrid=w=128:h=128:t=1:c=white@0.3,drawgrid=w=4:h=4:t=1:c=white@0.1,drawbox=w=5:h=5:t=1:x=90-2:y=256-240-3:c=red@0.5,drawbox=w=5:h=5:t=1:x=54-2:y=256-34-3:c=green@0.5,drawbox=w=5:h=5:t=1:x=240-2:y=256-110-3:c=blue@0.5,drawbox=w=5:h=5:t=1:x=166-2:y=256-16-3:c=cyan@0.5,drawbox=w=5:h=5:t=1:x=202-2:y=256-222-3:c=magenta@0.5,drawbox=w=5:h=5:t=1:x=16-2:y=256-146-3:c=yellow@0.5,scale=486:486'"
# Name: Vectorscope (field-split)
FILTER_VECTORSCOPE_FS="-vf 'split[a][b];[a]field=top[c];[b]field=bottom[d];[c]histogram=mode=color2,transpose=dir=2,drawgrid=w=16:h=16:t=1:c=white@0.2,drawgrid=w=128:h=128:t=1:c=white@0.3,drawgrid=w=4:h=4:t=1:c=white@0.1,drawbox=w=5:h=5:t=1:x=90-2:y=256-240-3:c=red@0.5,drawbox=w=5:h=5:t=1:x=54-2:y=256-34-3:c=green@0.5,drawbox=w=5:h=5:t=1:x=240-2:y=256-110-3:c=blue@0.5,drawbox=w=5:h=5:t=1:x=166-2:y=256-16-3:c=cyan@0.5,drawbox=w=5:h=5:t=1:x=202-2:y=256-222-3:c=magenta@0.5,drawbox=w=5:h=5:t=1:x=16-2:y=256-146-3:c=yellow@0.5[e];[d]histogram=mode=color2,transpose=dir=2,drawgrid=w=16:h=16:t=1:c=white@0.2,drawgrid=w=128:h=128:t=1:c=white@0.3,drawgrid=w=4:h=4:t=1:c=white@0.1,drawbox=w=5:h=5:t=1:x=90-2:y=256-240-3:c=red@0.5,drawbox=w=5:h=5:t=1:x=54-2:y=256-34-3:c=green@0.5,drawbox=w=5:h=5:t=1:x=240-2:y=256-110-3:c=blue@0.5,drawbox=w=5:h=5:t=1:x=166-2:y=256-16-3:c=cyan@0.5,drawbox=w=5:h=5:t=1:x=202-2:y=256-222-3:c=magenta@0.5,drawbox=w=5:h=5:t=1:x=16-2:y=256-146-3:c=yellow@0.5[f];[e]pad=iw*2[g];[g][f]overlay=w'"

# Name: Temporal Outlier Pixels
# Description: All pixels labeled as 'temporal outliers' will be highlighted as white pixels to illuminate what area(s) of the frame and how many pixels are temporal outliers
FILTER_TOUT="-vf 'values=out=tout'"
# Name: Temporal Outlier Pixels (field-split)
FILTER_TOUT_FS="-vf 'split[a][b];[a]field=top[c];[b]field=bottom[d];[c]values=out=tout[e];[d]values=out=tout[f];[e]pad=0:ih*2[g];[g][f]overlay=0:h'"

# Name: Extract Y
# Description: This filter extracts the Y channel which represents the luminosity data from the video. Only supported on YUV videos.
FILTER_EXTRACT_Y="-vf extractplanes=y"
# Name: Extract U
# Description: This filter extracts the U channel which represents part of the chroma data from the video. Only supported on YUV videos.
FILTER_EXTRACT_U="-vf extractplanes=u"
# Name: Extract V
# Description: This filter extracts the V channel which represents part of the chroma data from the video. Only supported on YUV videos.
FILTER_EXTRACT_V="-vf extractplanes=v"
# Name: Extract UV
# Description: This filter extracts both chroma channels, U and V, and presents them side-by-side. Only supported on YUV videos.
FILTER_EXTRACT_UV="-vf 'extractplanes=u+v[u][v];[u]pad=iw*2[u2];[u2][v]overlay=w,drawgrid=iw/2:ih:c=blue@0.2:t=1'"

# Name: Extract Y - Equalized
# Description: This filter extracts the Y channel which represents the luminosity data from the video and then applies a histogram equalization which redistributes the pixel intensities to equalize their distribution across the intensity range. This filter is useful for analyzing compressed video channel signals.
FILTER_EXTRACT_Y_EQ="-vf 'format=yuvj444p,extractplanes=y,histeq=strength=0.2'"
# Name: Extract U - Equalized
# Description: This filter extracts the U channel which represents part of the chroma data from the video and then applies a histogram equalization which redistributes the pixel intensities to equalize their distribution across the intensity range. This filter is useful for analyzing compressed video channel signals.
FILTER_EXTRACT_U_EQ="-vf 'format=yuvj444p,extractplanes=u,histeq=strength=0.2'"
# Name: Extract V - Equalized
# Description: This filter extracts the V channel which represents part of the chroma data from the video and then applies a histogram equalization which redistributes the pixel intensities to equalize their distribution across the intensity range. This filter is useful for analyzing compressed video channel signals.
FILTER_EXTRACT_V_EQ="-vf 'format=yuvj444p,extractplanes=v,histeq=strength=0.2'"

[ "$#" = 0 ] && { usage ; exit 1 ;};
while getopts fdHib:ABCDEFJKLMNOPQRSTUVWo:h opt ; do
    case "$opt" in
        f) filter="$fieldsplitplay" ;;
        d) filter="$fielddiffplay" ;;
        H) filter="$FILTER_HISTOGRAM" ;;
        W) filter="$FILTER_HISTOGRAM_FS" ;;
        b)
            bit="$OPTARG"
            [[ "$bit" == [1-8] ]] || { echo The bit value must be between 1 and 8 ; exit 1 ;}; 
            bitand=$(echo "2^(8-$bit)" | bc)
            times=$(echo "2^$bit" | bc)
            echo "bit $bit"
            filter="-vf 'split[a][b]; [a]pad=iw:ih*2,field=top,lutyuv=y=bitand(val\, $bitand)*$times:u=128:v=128[src]; [b]field=bottom,lutyuv=y=bitand(val\, $bitand)*$times:u=128:v=128[filt];[src][filt]overlay=0:h'";;
        A) filter="$FILTER_WAVEFORM" ;;
        B) filter="$FILTER_WAVEFORM_F1" ;;
        C) filter="$FILTER_WAVEFORM_F2" ;;
        D) filter="$FILTER_WAVEFORM_FS" ;;
        E) filter="$FILTER_RANG" ;;
        F) filter="$FILTER_RANG_FS" ;;
        J) filter="$FILTER_VECTORSCOPE" ;;
        K) filter="$FILTER_VECTORSCOPE_F1" ;;
        L) filter="$FILTER_VECTORSCOPE_F2" ;;
        M) filter="$FILTER_VECTORSCOPE_FS" ;;
        N) filter="$FILTER_TOUT" ;;
        O) filter="$FILTER_TOUT_FS" ;;
        P) filter="$FILTER_EXTRACT_Y" ;;
        Q) filter="$FILTER_EXTRACT_U" ;;
        R) filter="$FILTER_EXTRACT_V" ;;
        S) filter="$FILTER_EXTRACT_UV" ;;
        T) filter="$FILTER_EXTRACT_Y_EQ" ;;
        U) filter="$FILTER_EXTRACT_U_EQ" ;;
        V) filter="$FILTER_EXTRACT_V_EQ" ;;
        o) outputfile="$OPTARG" ;;
        h) usage ; exit 1 ;;
        \?) usage ; exit 1 ;;
    esac
done
shift $(( ${OPTIND} - 1 ))
inputfile="$1"
[ ! -f "$inputfile" ] && [ ! "$inputfile" = "-" ] && { echo No input file detected. ; usage ; exit 1 ;};
[ -n "$outputfile" ] && command="ffmpeg -i \"$inputfile\" $filter \"$outputfile\"" || command="ffplay \"$inputfile\" $filter"
echo "Running: $command"
eval "$command"
